// Copyright 2022 Antrea Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package openflow

import (
	"antrea.io/antrea/pkg/agent/openflow/cookie"
	binding "antrea.io/antrea/pkg/ovs/openflow"
	"antrea.io/antrea/pkg/util/runtime"
)

// OVS pipelines in AntreaProxy are generated by a framework called Flexible Pipeline. There are some concepts in this
// framework,
//
// +--------------+ +--------------+ +--------------+ +--------------+ +--------------+ +--------------+
// | FeatureTable | | FeatureTable | | FeatureTable | | FeatureTable | | FeatureTable | | FeatureTable |
// +--------------+ +--------------+ +--------------+ +--------------+ +--------------+ +--------------+
//         \               |                /                |                 \               /
//          \              |               /                 |                  \             /
//           \             |              /                  |                   \           /
//      +------------------------------------+        +--------------+       +--------------------+
//      |               Stage                |        |     Stage    |       |        Stage       |
//      +------------------------------------+        +--------------+       +--------------------+
//              \                                          /    \                        /
//               \                                        /      \                      /
//                \                                      /        \                    /
//              +------------------------------------------+    +--------------------------+
//              |                 Feature                  |    |          Feature         |
//              +------------------------------------------+    +--------------------------+
//                                  |                    \                         /
//                                  |                     \                       /
//                                  |                      \                     /
//                     +------------------------+        +-------------------------+
//                     |        Pipeline        |        |         Pipeline        |
//                     +------------------------+        +-------------------------+
//
// FeatureTable:
// FeatureTable in Flexible Pipeline is like "iptables entry" in iptables. It is the basic unit to build OVS pipelines.
//
// Stage:
// Stage in Flexible Pipeline is like "chain" in iptables. The order of Stages is fixed. A Stage can be empty or have
// one or more FeatureTables. Note that, a FeatureTable cannot be shared by different Stages. All Stages include,
//   - ClassifierStage
//	 - ValidationStage
//	 - ConntrackStateStage
//	 - PreRoutingStage
//	 - EgressSecurityStage
//	 - RoutingStage
//	 - PostRoutingStage
//	 - SwitchingStage
//	 - IngressSecurityStage
//	 - ConntrackStage
//	 - OutputStage
//
// Feature:
// Feature in Flexible Pipeline is like "table" in iptables. A Feature is intended to implement a major function. Note
// that, a Feature can have one or more Stages, and a Stage can be shared by multiple Features. All Features include,
//   - PodConnectivity, implementation of connectivity for Pods
//   - NetworkPolicy, implementation of K8s NetworkPolicy and Antrea NetworkPolicy
//   - Service, implementation of K8s Service
//   - Egress, implementation of Egress
//   - Traceflow, implementation of Traceflow
//   - Multicast, implementation of Multicast
//
// Pipeline:
// This is a concept in Flexible Pipeline, not OVS pipeline, but a corresponding OVS pipeline will be realized in OVS
// finally. A Pipeline is intended to implement a set of major functions. Note that, a Pipeline can have one or more
// Features, but a Feature can be shared by multiple Pipelines. All Pipelines include,
//   - Pipeline for IP
//   - Pipeline for ARP
//   - Pipeline for multicast
//
// How to insert a flow table with framework Flexible Pipeline?
// - Select a target Pipeline, Feature and Stage.
// - Define a FeatureTable with table name, Stage and priority. Arrange the FeatureTable in desired position with appropriate
//   priority value. For example, there is a Stage A which has FeatureTable A1 (priority 100) and FeatureTable A2 (priority 200)
//   declared by other Features. To insert a FeatureTable A3:
//     - between A1 and A2, the priority of A3 should have a priority between 101 to 199
//     - after A1, the priority of A3 should be less than 100
//     - before A2, the priority of A3 should be greater than 200
// - Reference the defined FeatureTable in target Feature. See method `getTemplate(p pipeline) *featureTemplate`.

// FeatureTable is just the concept of FeatureTable in framework Flexible Pipeline. If a FeatureTable is used by one
// or more active Features, then the FeatureTable will be used to build pipelines and its member struct ofTable will be
// initialized. Otherwise, it will be excluded from building pipelines. Note that, the order of all Stages is fixed, but
// the order of FeatureTables within a Stage is determined by priority. FeatureTable with a higher priority will be
// assigned with a smaller tableID for its corresponding flow table in realized OVS pipelines, which means a packet should
// enter the flow table before others with lower priorities in the same Stage.
type FeatureTable struct {
	name     string
	priority uint8
	stage    binding.StageID
	ofTable  binding.Table
}

type featureName string

const (
	PodConnectivity featureName = "PodConnectivity"
	NetworkPolicy   featureName = "NetworkPolicy"
	Service         featureName = "Service"
	Egress          featureName = "Egress"
	Traceflow       featureName = "Traceflow"
	Multicast       featureName = "Multicast"
)

// featureTemplate is a map to store which Stages and FeatureTables will be used for a Feature.
type featureTemplate struct {
	stageTables map[binding.StageID][]*FeatureTable
	feature     featureName
}

// feature is just the concept of Feature in framework Flexible Pipeline.
type feature interface {
	// getFeatureName gets the name of a Feature.
	getFeatureName() featureName
	// getTemplate gets featureTemplate. For a Feature, it can participate in build more than one Pipeline. In another
	// word, a Feature may have multiple Pipelines. For example, when IPv4 is enabled, Feature PodConnectivity needs
	// both Pipeline for IP and Pipeline for ARP.
	getTemplate(p pipeline) *featureTemplate
	// initFlows gets initialized flows.
	initFlows(category cookie.Category) []binding.Flow
	// replayFlows gets fixed and cached flows.
	replayFlows() []binding.Flow
}

// pipeline is just the concept of Pipeline in Flexible Pipeline.
type pipeline int

const (
	pipelineARP pipeline = iota + 1
	pipelineIP
	pipelineMulticast

	pipelineFirst = pipelineARP
	pipelineLast  = pipelineMulticast
)

// Pipeline for IP has 11 stages. These stages are:
//   - ClassifierStage  (shared with Pipeline for multicast)
//   - ValidationStage  (shared with Pipeline for multicast)
//   - ConntrackStateStage
//   - PreRoutingStage
//   - EgressSecurityStage
//   - RoutingStage
//   - PostRoutingStage
//   - SwitchingStage
//   - IngressSecurityStage
//   - ConntrackStage
//   - OutputStage

// Pipeline for ARP has 2 stages. These stages are:
//   - ValidationStage
//   - OutputStage

// Pipeline for multicast has 3 stages. These stages are:
//   - ClassifierStage (shared with Pipeline for IP)
//   - ValidationStage (shared with Pipeline for IP)
//   - RoutingStage
// Note that, Pipeline for multicast shares ClassifierStage and ValidationStage with Pipeline for IP. After these two
// shared Stages, multicast traffic and unicast traffic goes to different their own data path.

func newFeatureTable(tableName string, priority uint8, stage binding.StageID) *FeatureTable {
	return &FeatureTable{
		name:     tableName,
		priority: priority,
		stage:    stage,
	}
}

func (c *FeatureTable) GetID() uint8 {
	return c.ofTable.GetID()
}

func (c *FeatureTable) GetNext() uint8 {
	return c.ofTable.GetNext()
}

func (c *FeatureTable) GetName() string {
	return c.name
}

func (c *FeatureTable) GetMissAction() binding.MissActionType {
	return c.ofTable.GetMissAction()
}

func (f *featureTemplate) addTable(stage binding.StageID, table *FeatureTable) {
	f.stageTables[stage] = append(f.stageTables[stage], table)
}

func (c *featurePodConnectivity) getTemplate(p pipeline) *featureTemplate {
	var template *featureTemplate
	switch p {
	case pipelineIP:
		template = &featureTemplate{
			stageTables: map[binding.StageID][]*FeatureTable{
				binding.ClassifierStage: {
					ClassifierTable,
				},
				binding.ValidationStage: {
					SpoofGuardTable,
				},
				binding.ConntrackStateStage: {
					ConntrackTable,
					ConntrackStateTable,
				},
				binding.RoutingStage: {
					L3ForwardingTable,
					L3DecTTLTable,
				},
				binding.SwitchingStage: {
					L2ForwardingCalcTable,
				},
				binding.ConntrackStage: {
					ConntrackCommitTable,
				},
				binding.OutputStage: {
					L2ForwardingOutTable,
				},
			},
		}
		if c.enableMulticast {
			template.addTable(binding.ValidationStage, MulticastClassifierTable)
		}
		for _, ipProtocol := range c.ipProtocols {
			if ipProtocol == binding.ProtocolIPv6 {
				template.addTable(binding.ValidationStage, IPv6Table)
				break
			}
		}
	case pipelineARP:
		template = &featureTemplate{
			stageTables: map[binding.StageID][]*FeatureTable{
				binding.ValidationStage: {
					ARPSpoofGuardTable,
				},
				binding.OutputStage: {
					ARPResponderTable,
				},
			},
		}
	}

	return template
}

func (c *featureNetworkPolicy) getTemplate(p pipeline) *featureTemplate {
	if p != pipelineIP {
		return nil
	}
	template := &featureTemplate{
		stageTables: map[binding.StageID][]*FeatureTable{
			binding.EgressSecurityStage: {
				EgressRuleTable,
				EgressDefaultTable,
				EgressMetricTable,
			},
			binding.IngressSecurityStage: {
				IngressClassifierTable,
				IngressRuleTable,
				IngressDefaultTable,
				IngressMetricTable,
			},
		},
	}
	if c.enableAntreaPolicy {
		template.addTable(binding.EgressSecurityStage, AntreaPolicyEgressRuleTable)
		template.addTable(binding.IngressSecurityStage, AntreaPolicyIngressRuleTable)
	}
	return template
}

func (c *featureService) getTemplate(p pipeline) *featureTemplate {
	if p != pipelineIP {
		return nil
	}
	var template *featureTemplate
	if c.enableProxy {
		template = &featureTemplate{
			stageTables: map[binding.StageID][]*FeatureTable{
				binding.ConntrackStateStage: {
					SNATConntrackTable,
				},
				binding.PreRoutingStage: {
					SessionAffinityTable,
					ServiceLBTable,
					EndpointDNATTable,
				},
				binding.RoutingStage: {
					L3ForwardingTable,
					ServiceHairpinMarkTable,
				},
				binding.PostRoutingStage: {
					SNATConntrackCommitTable,
				},
				binding.ConntrackStage: {
					ConntrackCommitTable,
				},
				binding.OutputStage: {
					L2ForwardingOutTable,
				},
			},
		}
		if runtime.IsWindowsPlatform() {
			template.addTable(binding.ClassifierStage, UplinkTable)
		}
		if c.proxyAll {
			template.addTable(binding.PreRoutingStage, NodePortProbeTable)
		}
	} else {
		template = &featureTemplate{
			stageTables: map[binding.StageID][]*FeatureTable{
				binding.PreRoutingStage: {
					DNATTable,
				},
			},
		}
	}
	return template
}

func (c *featureEgress) getTemplate(p pipeline) *featureTemplate {
	if p != pipelineIP {
		return nil
	}
	return &featureTemplate{
		stageTables: map[binding.StageID][]*FeatureTable{
			binding.RoutingStage: {
				L3ForwardingTable,
			},
			binding.PostRoutingStage: {
				SNATTable,
			},
		},
	}
}

// Feature Traceflow does not need to declare any Stages.
func (c *featureTraceflow) getTemplate(p pipeline) *featureTemplate {
	if p != pipelineIP {
		return nil
	}
	return &featureTemplate{}
}

func (c *featureMulticast) getTemplate(p pipeline) *featureTemplate {
	if p != pipelineMulticast {
		return nil
	}
	return &featureTemplate{
		stageTables: map[binding.StageID][]*FeatureTable{
			binding.RoutingStage: {
				MulticastTable,
			},
		},
	}
}
